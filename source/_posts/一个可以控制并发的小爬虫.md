title: 一个可以控制并发的小爬虫
date: 2016-05-21 02:57:29
categories: 
- 编程
tags:
- Node
- JavaScript
- Async
---

# 最近好几个地方需要用到爬虫,解决了一下并发的问题

学校的选课系统的课容量做不到实时更新,但是一天更新一次还是可以的.但是用node直接一个for循环就几十个几百个http请求易轻尘发出去了.顶多能成功1 2个,后面的就全都失败了.所以需要控制并发.

<!-- more -->

## Async

Async是一个控制控制异步流程的库.可以控制异步函数执行的顺序.


form [http://blog.fens.me/nodejs-async/](http://blog.fens.me/nodejs-async/)
>3. Async函数介绍

>基于async的0.2.9版本。
async主要实现了三个部分的流程控制功能：
集合: Collections
流程控制: Control Flow
工具类: Utils

>1). 集合: Collections

>each: 如果想对同一个集合中的所有元素都执行同一个异步操作。
map: 对集合中的每一个元素，执行某个异步操作，得到结果。所有的结果将汇总到最终的callback里。与each的区别是，each只关心操作不管最后的值，而map关心的最后产生的值。
filter: 使用异步操作对集合中的元素进行筛选, 需要注意的是，iterator的callback只有一个参数，只能接收true或false。
reject: reject跟filter正好相反，当测试为true时则抛弃
reduce: 可以让我们给定一个初始值，用它与集合中的每一个元素做运算，最后得到一个值。reduce从左向右来遍历元素，如果想从右向左，可使用reduceRight。
detect: 用于取得集合中满足条件的第一个元素。
sortBy: 对集合内的元素进行排序，依据每个元素进行某异步操作后产生的值，从小到大排序。
some: 当集合中是否有至少一个元素满足条件时，最终callback得到的值为true，否则为false.
every: 如果集合里每一个元素都满足条件，则传给最终回调的result为true，否则为false
concat: 将多个异步操作的结果合并为一个数组。

>2). 流程控制: Control Flow

>series: 串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。
parallel: 并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序。
whilst: 相当于while，但其中的异步调用将在完成后才会进行下一次循环。
doWhilst: 相当于do…while, doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断。
until: until与whilst正好相反，当test为false时循环，与true时跳出。其它特性一致。
doUntil: doUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致。
forever: 无论条件循环执行，如果不出错，callback永远不被执行。
waterfall: 按顺序依次执行一组函数。每个函数产生的值，都将传给下一个。
compose: 创建一个包括一组异步函数的函数集合，每个函数会消费上一次函数的返回值。把f(),g(),h()异步函数，组合成f(g(h()))的形式，通过callback得到返回值。
applyEach: 实现给一数组中每个函数传相同参数，通过callback返回。如果只传第一个参数，将返回一个函数对象，我可以传参调用。
queue: 是一个串行的消息队列，通过限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用。
cargo: 一个串行的消息队列，类似于queue，通过限制了worker数量，不再一次性全部执行。不同之处在于，cargo每次会加载满额的任务做为任务单元，只有任务单元中全部执行完成后，才会加载新的任务单元。
auto: 用来处理有依赖关系的多个任务的执行。
iterator: 将一组函数包装成为一个iterator，初次调用此iterator时，会执行定义中的第一个函数并返回第二个函数以供调用。
apply: 可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码。
nextTick: 与nodejs的nextTick一样，再最后调用函数。
times: 异步运行,times可以指定调用几次，并把结果合并到数组中返回
timesSeries: 与time类似，唯一不同的是同步执行

>3). 工具类: Utils

>memoize: 让某一个函数在内存中缓存它的计算结果。对于相同的参数，只计算一次，下次就直接拿到之前算好的结果。
unmemoize: 让已经被缓存的函数，返回不缓存的函数引用。
log: 执行某异步函数，并记录它的返回值，日志输出。
dir: 与log类似，不同之处在于，会调用浏览器的console.dir()函数，显示为DOM视图。
noConflict: 如果之前已经在全局域中定义了async变量，当导入本async.js时，会先把之前的async变量保存起来，然后覆盖它。仅仅用于浏览器端，在nodejs中没用，这里无法演示。

之前想要把异步的第三方库同步化的时候找了一些方法,偶然看到了这个库,最后虽然没能解决想要的问题,但是习惯了异步之后也之前的问题也就不再是问题了.

```javascript
var n = require('needle');
var async = require('async');
var fs = require('fs');
var arr = [];

var start = -15;
var step = 100;
var end = 10000;

for (conditions) {
  arr.push(url());
}

spy(arr);

function url(x) {
  return 'url';
}

function spy(array, resp) {
  console.log('arr', arr);
  console.log('resp', resp);
  if (array) {
    async.mapLimit(arr, 3, reqAndWrite, spy);
  } else {
    console.log('finish');
  }
}

function reqAndWrite(x, callback) {
  var u = url(x);
  n.get(u, { encoding: 'gb2312' }, function (err, res) {
    if (res || ("body" in res) || (err)) {
      fs.writeFileSync('table/' + x + '.html', res.body);
      callback(undefined, x);
    } else {
      callback(x);
    }
  });
}
```

这是我用来抓学校选课系统的爬虫,学校系统比较简单,只需要不停地GET就能取到数据.这里是直接把爬回来的数据存到了文件里.

用到的http请求的库是`needle`,之前没仔细去啃`request`的文档的时候没找到怎么解决编码问题.学校的系统比较老,用的是`gb2312`的编码.

map的使用方法是这样的

```javascript
async.map(array,your_function,callback);
```
`array`中元素会分别传递给`your_function`
在`your_function`中调用`callback`,在`array`中所有的元素都经过`your_function`处理过之后,结果会拼接为一个数组传递给`callback`

比如说,
```javascript
var async=require('async');
var arr=[1,3,5,7];

function my_function(x,callback){
    callback(undefined,x+1);
}

async.map(arr,my_function,function(array,res) {
    console.log(res);
});
```
数组中的每一个元素分别传递给`my_function`,然后调用callback,最后的结果会是
```
[2,4,6,8]
```

相应的有一另外一个方法`mapLimit(coll, limit, iteratee, [callback])`,其中limit可以设置最大同时进行的函数的数量.只要在这里设置一个比较小的数字,就可以控制并发了.(因为我们学校选课系统比较脆弱,我设置了3或者5)

## 递归

为了保证所有的课表都被爬一遍,如果是同步的话可以用循环来进行,但是这里是异步,我没想到怎么通过循环来进行,所以用了递归.

递归真是有毒啊.